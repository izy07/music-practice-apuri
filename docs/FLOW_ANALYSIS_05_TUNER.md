# 機能フロー分析レポート #5: チューナーフロー

## 概要
チューナー機能（削除済み）、開放弦の音再生、メトロノーム機能の各フローを詳細に分析し、余分な工程や潜在的なバグを特定する。

## 1. チューナー機能フロー（削除済み）

### 現状
- **チューナー機能は削除済み**（`app/(tabs)/tuner.tsx:292-299`）
- UIは表示されているが、機能は動作しない
- `startListening()`と`stopListening()`はアラート表示のみ

### データの流れ
```
[チューナーボタンクリック]
  ↓
startListening()
  └─ Alert.alert('機能は利用できません', 'チューナー機能は現在利用できません')
```

### 問題点

#### 🟡 問題1: 削除された機能のUIが残存
**場所**: `app/(tabs)/tuner.tsx:448-520`
- チューナー機能のUIが表示されているが、機能は動作しない
- ユーザーが混乱する可能性

**改善提案**: 
- チューナー機能のUIを非表示にする
- または、機能再実装の予定がある場合は明示的に表示

## 2. 開放弦の音再生フロー

### ユーザー操作の流れ
1. チューナー画面で「開放弦の音を聞く」セクションを開く
2. 音名表示モードを選択（CDE / ドレミ）
3. 開放弦の音をタップ
4. 音が連続再生される
5. 停止ボタンをタップして停止

### データの流れ

#### フロントエンド処理 (`app/(tabs)/tuner.tsx`)
```
[開放弦ボタンクリック]
  ↓
playOpenString(frequency, note)
  ├─ プラットフォームチェック（Web環境のみ）
  │  └─ Platform.OS !== 'web' → Alert表示
  ├─ AudioContext作成/再開
  │  ├─ audioContextRef.current が存在しない場合は作成
  │  └─ suspended状態の場合はresume()
  ├─ 既存の音を停止
  │  └─ stopOpenString()
  ├─ 100ms待機（クリーンアップのため）
  ├─ OscillatorNode作成
  ├─ GainNode作成
  ├─ 接続（oscillator → gainNode → destination）
  ├─ 周波数設定
  ├─ フェードイン（0 → 0.3）
  └─ 再生開始
  ↓
[停止ボタンクリック]
  ↓
stopOpenString()
  ├─ フェードアウト（0.1秒）
  ├─ 150ms後に停止・切断
  └─ 状態クリア
```

### 問題点・余分な工程

#### 🟡 問題1: 100ms固定待機
**場所**: `app/(tabs)/tuner.tsx:327`
```typescript
await new Promise(resolve => setTimeout(resolve, 100));
```

**問題**: 
- クリーンアップのための固定待機時間
- 不確実（実際のクリーンアップ完了を待っていない）

**改善提案**: 
- Promiseベースでクリーンアップ完了を待つ
- または、AudioContextの状態を確認してから処理

#### 🟡 問題2: 150ms固定待機での停止処理
**場所**: `app/(tabs)/tuner.tsx:371-385`
```typescript
setTimeout(() => {
  // オシレーター停止・切断
}, 150);
```

**問題**: 
- フェードアウト後に固定150ms待機
- フェードアウトの完了を待っていない

**改善提案**: 
- フェードアウトの完了を待つ（`linearRampToValueAtTime`の完了を確認）
- または、`AudioContext.currentTime`を使用して正確なタイミングで処理

#### 🟡 問題3: AudioContextのクリーンアップ不足
**場所**: `app/(tabs)/tuner.tsx:264`
- `audioContextRef`は作成されるが、コンポーネントのアンマウント時のクリーンアップがない

**改善提案**: 
- `useEffect`のクリーンアップ関数で`AudioContext`を閉じる
- メモリリークを防ぐ

## 3. メトロノーム機能フロー

### ユーザー操作の流れ
1. チューナー画面でメトロノームモードを選択
2. メトロノームコンポーネントが表示される
3. BPMや拍子を設定
4. 再生ボタンをクリック
5. メトロノームが再生される

### データの流れ

#### フロントエンド処理
```
[メトロノームモード選択]
  ↓
setMode('metronome')
  ↓
Metronomeコンポーネント表示
  └─ components/metronome/Metronome.tsx
```

### 問題点

特に大きな問題は見当たらない（Metronomeコンポーネントの詳細は別途確認が必要）。

## 4. 音名表示モードの保存・読み込み

### データの流れ (`app/(tabs)/tuner.tsx:266-289`)
```
画面読み込み時
  ↓
AsyncStorageから読み込み
  ├─ '@tuner_note_display_mode' → 'en' | 'ja'
  └─ 状態を更新
  ↓
[音名表示モード変更]
  ↓
saveNoteDisplayMode(mode)
  ├─ AsyncStorageに保存
  └─ 状態を更新
```

### 問題点

特に大きな問題は見当たらない。

## 5. 楽器別チューニング設定

### データの流れ (`app/(tabs)/tuner.tsx:228-253`)
```
[楽器選択変更]
  ↓
contextSelectedInstrument取得
  ↓
instrumentIdToTunerKeyマッピング
  ├─ データベースの楽器ID → チューナー楽器キー
  └─ フォールバック: 'guitar'
  ↓
INSTRUMENT_TUNINGS[selectedInstrument]
  └─ 楽器別の開放弦情報を取得
```

### 問題点

#### 🟡 問題1: 楽器IDとチューナーキーのマッピングがハードコード
**場所**: `app/(tabs)/tuner.tsx:229-251`
- 楽器IDとチューナーキーのマッピングがコード内にハードコードされている
- 楽器が追加された場合、コード修正が必要

**改善提案**: 
- データベースにマッピング情報を保存
- または、設定ファイルに分離

## 6. 余分なファイル・重複コード

### 未使用の可能性があるファイル
- `lib/tunerAudioProcessor.ts` - チューナー機能が削除されているため、使用されていない可能性
- `components/TuningSoundPlayer.tsx` - 使用されているか確認が必要

## 7. 潜在的なバグ

### バグ1: AudioContextのメモリリーク
- `audioContextRef`が作成されるが、コンポーネントのアンマウント時に閉じられていない
- 複数回AudioContextが作成される可能性

### バグ2: オシレーターのクリーンアップ不備
- 停止処理が固定時間待機のため、実際の停止を待っていない
- 複数のオシレーターが同時に再生される可能性

## 8. 改善提案まとめ

### 優先度: 高
1. **AudioContextのクリーンアップ**: コンポーネントアンマウント時に閉じる
2. **オシレーターのクリーンアップ改善**: Promiseベースで処理

### 優先度: 中
3. **固定待機時間の削除**: Promiseベースで処理
4. **削除されたチューナー機能のUI非表示**: ユーザー混乱を防ぐ

### 優先度: 低
5. **楽器IDとチューナーキーのマッピング外部化**: 設定ファイルに分離

## 9. フロー図（テキストベース）

### 開放弦の音再生フロー
```
[開放弦ボタンクリック]
  ↓
[プラットフォームチェック] ← ⚠️ Web環境のみ
  ↓
[AudioContext作成/再開]
  ↓
[既存の音を停止]
  ↓
[100ms待機] ← ⚠️ 固定待機
  ↓
[OscillatorNode作成]
  ↓
[GainNode作成]
  ↓
[接続・設定]
  ↓
[フェードイン]
  ↓
[再生開始]
```

### 停止フロー
```
[停止ボタンクリック]
  ↓
[フェードアウト開始]
  ↓
[150ms後に停止] ← ⚠️ 固定待機
  ↓
[オシレーター停止・切断]
  ↓
[状態クリア]
```

## 10. 結論

チューナーフローは以下の問題がある：
- 削除された機能のUIが残存
- AudioContextのクリーンアップ不足
- 固定待機時間の使用
- オシレーターのクリーンアップ不備

これらの改善により、メモリリークの防止とコードの可読性向上が期待できる。

