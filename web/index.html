<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta httpEquiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' https:; frame-src 'self' https:; object-src 'none'; base-uri 'self'; form-action 'self';" />
  <title>Music Practice</title>
  <script>
    // aria-hidden警告を根本的に抑制（DOMレベル）
    // inert属性を使用したモーダル管理と組み合わせて使用
    (function() {
      if (typeof window === 'undefined') return;
      
      // フォーカス可能な要素のセレクタ
      const focusableSelector = 'input, textarea, select, button, a, [tabindex]:not([tabindex="-1"]), [contenteditable="true"]';
      
      // 要素がinert属性を持つか、その祖先がinert属性を持つかチェック
      const isInInertTree = function(element) {
        let current = element;
        while (current && current !== document.body) {
          if (current.hasAttribute && current.hasAttribute('inert')) {
            return true;
          }
          current = current.parentElement;
        }
        return false;
      };
      
      // 要素がモーダル内にあるかチェック
      const isInModal = function(element) {
        return element.closest('[role="dialog"]') || 
               element.closest('[aria-modal="true"]') ||
               element.closest('[data-modal-content]');
      };
      
      // aria-hidden属性の設定を根本的にブロック（inert属性を使用）
      const originalSetAttribute = Element.prototype.setAttribute;
      Element.prototype.setAttribute = function(name, value) {
        if (name === 'aria-hidden' && value === 'true') {
          // inert属性が設定されている場合は、aria-hiddenの設定を許可
          // （inert属性がフォーカス管理を適切に処理するため）
          if (this.hasAttribute && this.hasAttribute('inert')) {
            return originalSetAttribute.call(this, name, value);
          }
          
          // モーダル内の要素の場合は許可（モーダル自体にはaria-hiddenを設定しても良い）
          if (isInModal(this)) {
            return originalSetAttribute.call(this, name, value);
          }
          
          // フォーカス可能な要素が含まれている場合は設定を完全にブロック
          try {
            const focusableElements = this.querySelectorAll ? this.querySelectorAll(focusableSelector) : [];
            if (focusableElements.length > 0) {
              // モーダル内の要素の場合は許可
              const hasModalContent = Array.from(focusableElements).some(el => isInModal(el));
              if (!hasModalContent) {
                // フォーカス可能な要素が含まれている場合は設定を完全にブロック
                // inert属性を設定することで、フォーカス管理を適切に行う
                if (!this.hasAttribute('inert')) {
                  this.setAttribute('inert', '');
                }
                return; // aria-hiddenの設定をブロック
              }
            }
          } catch (e) {
            // エラーが発生した場合は設定をブロック（安全のため）
            return;
          }
          
          // フォーカス可能な要素がない場合でも、背景要素の場合はinert属性を使用
          // React Native Webが設定する背景のaria-hiddenをブロック
          const isBackgroundElement = this === document.body || 
                                      this === document.getElementById('root') ||
                                      (this.parentElement && (this.parentElement === document.body || this.parentElement.id === 'root'));
          
          if (isBackgroundElement) {
            // inert属性を設定して、aria-hiddenの代わりにする
            if (!this.hasAttribute('inert')) {
              this.setAttribute('inert', '');
            }
            return; // aria-hiddenの設定をブロック
          }
        }
        return originalSetAttribute.call(this, name, value);
      };
      
      // フォーカスイベントを監視して、フォーカスされた要素の祖先のaria-hiddenを削除
      const handleFocus = function(event) {
        const target = event.target;
        if (!target) return;
        
        // inert属性が設定されている場合は、aria-hiddenの削除は不要
        if (isInInertTree(target)) {
          return;
        }
        
        // モーダル内の要素の場合は、aria-hiddenの削除は不要
        if (isInModal(target)) {
          return;
        }
        
        // フォーカスされた要素のすべての祖先をチェック（より積極的に削除）
        let current = target;
        while (current && current !== document.body && current !== document.documentElement) {
          if (current.hasAttribute && current.hasAttribute('aria-hidden') && current.getAttribute('aria-hidden') === 'true') {
            // inert属性が設定されている場合は削除しない
            if (!isInInertTree(current) && !isInModal(current)) {
              // 即座にaria-hiddenを削除（警告を防ぐ）
              current.removeAttribute('aria-hidden');
              // inert属性を設定して、再設定を防ぐ
              if (!current.hasAttribute('inert')) {
                current.setAttribute('inert', '');
              }
            }
          }
          current = current.parentElement;
        }
      };
      
      // aria-hidden警告を抑制（コンソール警告を無視）
      const originalWarn = console.warn;
      console.warn = function(...args) {
        // aria-hiddenに関する警告は無視
        if (args.length > 0 && typeof args[0] === 'string' && args[0].includes('aria-hidden')) {
          return;
        }
        originalWarn.apply(console, args);
      };
      
      // DOMが読み込まれたらイベントリスナーを追加
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
          document.addEventListener('focusin', handleFocus, true);
        });
      } else {
        document.addEventListener('focusin', handleFocus, true);
      }
      
      // MutationObserverでaria-hidden属性の追加を監視（即座に削除）
      const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          if (mutation.type === 'attributes' && mutation.attributeName === 'aria-hidden') {
            const target = mutation.target;
            if (!target || !target.hasAttribute) return;
            
            // inert属性が設定されている場合は、aria-hiddenの削除は不要
            if (isInInertTree(target)) {
              return;
            }
            
            // モーダル内の要素の場合は許可
            if (isInModal(target)) {
              return;
            }
            
            // aria-hiddenが設定されている場合、即座に削除
            if (target.hasAttribute('aria-hidden') && target.getAttribute('aria-hidden') === 'true') {
              // フォーカス可能な要素をチェック
              try {
                const focusableElements = target.querySelectorAll ? target.querySelectorAll(focusableSelector) : [];
                if (focusableElements.length > 0) {
                  // モーダル内の要素の場合は許可
                  const hasModalContent = Array.from(focusableElements).some(el => isInModal(el));
                  if (!hasModalContent) {
                    // フォーカス可能な要素が含まれている場合は即座にaria-hiddenを削除
                    // 代わりにinert属性を設定
                    target.removeAttribute('aria-hidden');
                    if (!target.hasAttribute('inert')) {
                      target.setAttribute('inert', '');
                    }
                    return;
                  }
                }
                
                // フォーカス可能な要素がなくても、背景要素の場合は削除
                const isBackgroundElement = target === document.body || 
                                            target === document.getElementById('root') ||
                                            (target.parentElement && (target.parentElement === document.body || target.parentElement.id === 'root'));
                
                if (isBackgroundElement) {
                  target.removeAttribute('aria-hidden');
                  if (!target.hasAttribute('inert')) {
                    target.setAttribute('inert', '');
                  }
                }
              } catch (e) {
                // エラーが発生した場合は無視
              }
            }
          }
          
          // ノードが追加された場合もチェック
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach(function(node) {
              if (node.nodeType === 1) { // Element node
                const element = node;
                if (element.hasAttribute && element.hasAttribute('aria-hidden') && element.getAttribute('aria-hidden') === 'true') {
                  // inert属性が設定されている場合は、aria-hiddenの削除は不要
                  if (isInInertTree(element)) {
                    return;
                  }
                  
                  try {
                    const focusableElements = element.querySelectorAll ? element.querySelectorAll(focusableSelector) : [];
                    if (focusableElements.length > 0) {
                      // モーダル内の要素の場合は許可
                      const hasModalContent = Array.from(focusableElements).some(el => isInModal(el));
                      if (!hasModalContent) {
                        element.removeAttribute('aria-hidden');
                      }
                    }
                  } catch (e) {
                    // エラーが発生した場合は無視
                  }
                }
              }
            });
          }
        });
      });
      
      // DOMが読み込まれたら監視を開始
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
          observer.observe(document.body, {
            attributes: true,
            attributeFilter: ['aria-hidden'],
            subtree: true,
            childList: true
          });
        });
      } else {
        observer.observe(document.body, {
          attributes: true,
          attributeFilter: ['aria-hidden'],
          subtree: true,
          childList: true
        });
      }
      
      // 定期的にaria-hiddenをチェック（フォールバック）- より頻繁にチェック
      setInterval(function() {
        const elementsWithAriaHidden = document.querySelectorAll('[aria-hidden="true"]');
        elementsWithAriaHidden.forEach(function(element) {
          // inert属性が設定されている場合は、aria-hiddenの削除は不要
          if (isInInertTree(element)) {
            return;
          }
          
          // モーダル内の要素の場合は許可
          if (isInModal(element)) {
            return;
          }
          
          try {
            const focusableElements = element.querySelectorAll ? element.querySelectorAll(focusableSelector) : [];
            if (focusableElements.length > 0) {
              // モーダル内の要素の場合は許可
              const hasModalContent = Array.from(focusableElements).some(el => isInModal(el));
              if (!hasModalContent) {
                // 即座にaria-hiddenを削除し、inert属性を設定
                element.removeAttribute('aria-hidden');
                if (!element.hasAttribute('inert')) {
                  element.setAttribute('inert', '');
                }
                return;
              }
            }
            
            // フォーカス可能な要素がなくても、背景要素の場合は削除
            const isBackgroundElement = element === document.body || 
                                      element === document.getElementById('root') ||
                                      (element.parentElement && (element.parentElement === document.body || element.parentElement.id === 'root'));
            
            if (isBackgroundElement) {
              element.removeAttribute('aria-hidden');
              if (!element.hasAttribute('inert')) {
                element.setAttribute('inert', '');
              }
            }
          } catch (e) {
            // エラーが発生した場合は無視
          }
        });
      }, 50); // 100ms → 50msに短縮（より頻繁にチェックして警告を防ぐ）
    })();
  </script>
  <style>
    html, body, #root {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    #root {
      display: flex;
      flex-direction: column;
    }
    /* Expo Routerタブバーのスクロール矢印を非表示 */
    [data-testid*="scroll-arrow"],
    [class*="scroll-arrow"],
    [class*="ScrollArrow"],
    button[aria-label*="scroll"],
    button[aria-label*="arrow"],
    button[aria-label*="arrow-down"],
    svg[class*="arrow"],
    [class*="chevron-down"] {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
      visibility: hidden !important;
      opacity: 0 !important;
    }
    
    /* タブバーの右側の余白を完全に削除 */
    nav[role="tablist"],
    [class*="tab-bar"],
    [class*="TabBar"] {
      padding-right: 0 !important;
      margin-right: 0 !important;
      width: 100% !important;
      max-width: 100% !important;
      overflow: hidden !important;
    }
    
    /* タブバーの最後の要素の右側余白を削除 */
    nav[role="tablist"] > *:last-child,
    [class*="tab-bar"] > *:last-child,
    [class*="TabBar"] > *:last-child {
      padding-right: 0 !important;
      margin-right: 0 !important;
    }
    
    /* タブバーのルートコンテナとすべての親要素の余白を削除 */
    nav[role="tablist"],
    nav[class*="tab"],
    nav[class*="Tab"],
    div[class*="tab-bar"],
    div[class*="TabBar"],
    [class*="tab-bar"],
    [class*="TabBar"],
    [role="tablist"],
    [data-testid*="tab-bar"],
    [data-testid*="TabBar"] {
      padding: 0 !important;
      padding-left: 0 !important;
      padding-right: 0 !important;
      padding-top: 0 !important;
      padding-bottom: 0 !important;
      margin: 0 !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
      margin-top: 0 !important;
      margin-bottom: 0 !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 100% !important;
      box-sizing: border-box !important;
      overflow: hidden !important;
    }
    
    /* タブバーのスクロールコンテナの余白を削除 */
    [class*="tab-bar"] [class*="scroll"],
    [class*="TabBar"] [class*="scroll"],
    [class*="tab-bar"] [class*="ScrollView"],
    [class*="TabBar"] [class*="ScrollView"],
    [role="tablist"] [class*="scroll"],
    [role="tablist"] [class*="ScrollView"],
    nav[role="tablist"] > div,
    nav[class*="tab"] > div,
    [class*="tab-bar"] > div,
    [class*="TabBar"] > div {
      padding: 0 !important;
      padding-left: 0 !important;
      padding-right: 0 !important;
      margin: 0 !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 100% !important;
      box-sizing: border-box !important;
      overflow-x: hidden !important;
      overflow-y: hidden !important;
    }
    
    /* タブバーのコンテンツコンテナの余白を削除 */
    [class*="tab-bar"] > *,
    [class*="TabBar"] > *,
    [role="tablist"] > *,
    [class*="tab-bar"] [class*="content"],
    [class*="TabBar"] [class*="content"],
    nav[role="tablist"] > *,
    nav[class*="tab"] > * {
      padding: 0 !important;
      padding-left: 0 !important;
      padding-right: 0 !important;
      margin: 0 !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
      box-sizing: border-box !important;
    }
    
    /* タブバーの最後の要素の余白を削除 */
    [class*="tab-bar"] > *:last-child,
    [class*="TabBar"] > *:last-child,
    [role="tablist"] > *:last-child,
    [class*="tab-bar"] [class*="content"] > *:last-child,
    [class*="TabBar"] [class*="content"] > *:last-child,
    nav[role="tablist"] > *:last-child {
      padding-right: 0 !important;
      margin-right: 0 !important;
    }
    
    /* タブアイテムの余白を削除（表示されているタブのみ） */
    [class*="tab-bar"] button:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty),
    [class*="TabBar"] button:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty),
    [role="tablist"] button:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty),
    [role="tab"]:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty),
    [class*="tab-item"]:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty),
    [class*="TabItem"]:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty),
    nav[role="tablist"] button:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty),
    nav[class*="tab"] button:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty) {
      padding: 0 !important;
      padding-left: 0 !important;
      padding-right: 0 !important;
      margin: 0 !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
      flex: 1 !important;
      min-width: 0 !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
      width: auto !important;
    }
    
    /* 非表示タブ（空のボタンや幅0のボタン）を完全に削除 */
    [class*="tab-bar"] button:empty,
    [class*="TabBar"] button:empty,
    [role="tablist"] button:empty,
    [role="tab"]:empty,
    [class*="tab-bar"] button[style*="display: none"],
    [class*="TabBar"] button[style*="display: none"],
    [role="tablist"] button[style*="display: none"],
    [class*="tab-bar"] button[aria-hidden="true"],
    [class*="TabBar"] button[aria-hidden="true"],
    [role="tablist"] button[aria-hidden="true"],
    /* 幅0またはflex: 0の要素を非表示 */
    [class*="tab-bar"] button[style*="width: 0"],
    [class*="TabBar"] button[style*="width: 0"],
    [role="tablist"] button[style*="width: 0"],
    [class*="tab-bar"] button[style*="flex: 0"],
    [class*="TabBar"] button[style*="flex: 0"],
    [role="tablist"] button[style*="flex: 0"] {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
      padding: 0 !important;
      margin: 0 !important;
      visibility: hidden !important;
      opacity: 0 !important;
      flex: 0 !important;
      min-width: 0 !important;
      max-width: 0 !important;
      position: absolute !important;
      left: -9999px !important;
    }
    
    /* 非表示タブの親要素もスペースを取らないようにする */
    [class*="tab-bar"] > *:empty,
    [class*="TabBar"] > *:empty,
    [role="tablist"] > *:empty {
      display: none !important;
      width: 0 !important;
      padding: 0 !important;
      margin: 0 !important;
      flex: 0 !important;
    }
    
    /* タブバーのコンテンツコンテナで、表示されているタブのみをカウント */
    [role="tablist"] > *:not([style*="display: none"]):not(:empty):not([style*="width: 0"]):not([style*="flex: 0"]) {
      flex: 1 !important;
    }
    
    /* 非表示タブの親要素もスペースを取らないようにする */
    [role="tablist"] > *[style*="display: none"],
    [role="tablist"] > *[style*="width: 0"],
    [role="tablist"] > *[style*="flex: 0"] {
      display: none !important;
      width: 0 !important;
      flex: 0 !important;
      padding: 0 !important;
      margin: 0 !important;
    }
    
    /* タブバーの右側の余白を完全に削除（すべての要素に対して） */
    [role="tablist"] * {
      box-sizing: border-box !important;
    }
    
    /* タブバーの最後の表示されているタブの右側余白を削除 */
    [role="tablist"] > *:last-child:not([style*="display: none"]):not(:empty),
    [role="tablist"] > *:last-child button,
    [role="tablist"] > *:last-child [role="tab"],
    nav[role="tablist"] > *:last-child:not([style*="display: none"]):not(:empty),
    nav[role="tablist"] > *:last-child button,
    nav[role="tablist"] > *:last-child [role="tab"],
    [class*="tab-bar"] > *:last-child,
    [class*="TabBar"] > *:last-child {
      padding-right: 0 !important;
      margin-right: 0 !important;
      padding-end: 0 !important;
      margin-end: 0 !important;
      border-right: none !important;
    }
    
    /* タブバーのコンテナ全体の右側余白を削除 */
    [role="tablist"],
    nav[role="tablist"],
    [class*="tab-bar"],
    [class*="TabBar"],
    [class*="tab-bar-content"],
    [class*="TabBarContent"] {
      padding-right: 0 !important;
      margin-right: 0 !important;
      padding-end: 0 !important;
      margin-end: 0 !important;
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
    }
    
    /* タブバーの内部コンテナの右側余白を削除 */
    [role="tablist"] > div,
    nav[role="tablist"] > div,
    [class*="tab-bar"] > div,
    [class*="TabBar"] > div {
      padding-right: 0 !important;
      margin-right: 0 !important;
      padding-end: 0 !important;
      margin-end: 0 !important;
      width: 100% !important;
      max-width: 100% !important;
    }
    
    /* タブバーのすべての子要素の余白を削除（再帰的） */
    [class*="tab-bar"] *,
    [class*="TabBar"] *,
    [role="tablist"] *,
    nav[role="tablist"] * {
      box-sizing: border-box !important;
    }
    
    /* タブバーの親コンテナの余白も削除 */
    body > div,
    #root > div,
    [class*="expo-router"] {
      padding-right: 0 !important;
      margin-right: 0 !important;
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
    }
    
    /* タブバーの右側余白を完全に削除 - より強力なルール */
    nav[role="tablist"] {
      justify-content: flex-start !important;
    }
    
    /* タブバーの最後のタブの右側余白を完全に削除 */
    nav[role="tablist"] > button:last-child,
    nav[role="tablist"] > a:last-child,
    nav[role="tablist"] > div:last-child button,
    [class*="tab-bar"] button:last-child,
    [class*="TabBar"] button:last-child {
      padding-right: 0 !important;
      margin-right: 0 !important;
      padding-end: 0 !important;
      margin-end: 0 !important;
      border-right: none !important;
    }
    
    /* タブバーのコンテナ全体を100%幅に */
    nav[role="tablist"],
    [class*="tab-bar"],
    [class*="TabBar"] {
      width: 100vw !important;
      max-width: 100vw !important;
      margin-right: 0 !important;
      padding-right: 0 !important;
    }
    
    /* すべてのタブボタンを均等に配置 */
    nav[role="tablist"] > button,
    nav[role="tablist"] > a,
    [class*="tab-bar"] button,
    [class*="TabBar"] button {
      flex: 1 1 0% !important;
      min-width: 0 !important;
      max-width: 100% !important;
    }
    
    /* タブバーの右側余白を完全に削除 - 最強のルール */
    body,
    html,
    #root,
    #root > *,
    [class*="expo-router"],
    [data-expo-router-root],
    nav[role="tablist"],
    nav[role="tablist"] *,
    [class*="tab-bar"],
    [class*="tab-bar"] *,
    [class*="TabBar"],
    [class*="TabBar"] * {
      box-sizing: border-box !important;
    }
    
    /* タブバーコンテナの右側余白を完全に削除 */
    nav[role="tablist"]:after,
    nav[role="tablist"]::after,
    [class*="tab-bar"]:after,
    [class*="tab-bar"]::after,
    [class*="TabBar"]:after,
    [class*="TabBar"]::after {
      display: none !important;
      content: none !important;
      width: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
    }
    
    /* タブバー全体の幅を100vwに固定し、右側余白を削除 */
    nav[role="tablist"],
    [class*="tab-bar"],
    [class*="TabBar"] {
      position: relative !important;
      left: 0 !important;
      right: 0 !important;
      width: 100vw !important;
      max-width: 100vw !important;
      margin-right: 0 !important;
      padding-right: 0 !important;
      padding-end: 0 !important;
      margin-end: 0 !important;
      overflow: hidden !important;
    }
    
    /* タブバーの最後の要素とそのすべての子要素の右側余白を削除 */
    nav[role="tablist"] > *:last-child,
    nav[role="tablist"] > *:last-child *,
    [class*="tab-bar"] > *:last-child,
    [class*="tab-bar"] > *:last-child *,
    [class*="TabBar"] > *:last-child,
    [class*="TabBar"] > *:last-child * {
      padding-right: 0 !important;
      margin-right: 0 !important;
      padding-end: 0 !important;
      margin-end: 0 !important;
      border-right: none !important;
    }
    
    /* タブバーのコンテンツを左寄せし、右側に余白を作らない */
    nav[role="tablist"],
    [class*="tab-bar-content"],
    [class*="TabBarContent"] {
      justify-content: flex-start !important;
      align-items: stretch !important;
      width: 100% !important;
      max-width: 100% !important;
      flex-wrap: nowrap !important;
    }
    
    /* すべてのタブアイテムを均等に配置し、右側余白を削除 */
    [role="tablist"] > *,
    [class*="tab-bar"] > *,
    [class*="TabBar"] > * {
      flex: 1 1 0% !important;
      min-width: 0 !important;
      padding-right: 0 !important;
      margin-right: 0 !important;
      padding-end: 0 !important;
      margin-end: 0 !important;
      box-sizing: border-box !important;
    }
  </style>
  <!-- Expo Router Web Support -->
  <script>
    // Expo RouterのWebルーティングを有効化
    // すべてのルートをindex.htmlにリダイレクト
    if (typeof window !== 'undefined') {
      // クライアントサイドルーティングを有効化
      window.__EXPO_ROUTER_ENABLED__ = true;
    }
  </script>
</head>
<body>
  <div id="root"></div>
</body>
</html>
