<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta httpEquiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' https:; frame-src 'self' https:; object-src 'none'; base-uri 'self'; form-action 'self';" />
  <!-- Favicon（動的に解決） -->
  <script>
    // アイコンパスを動的に解決（開発環境と本番環境で異なる）
    (function() {
      if (typeof window === 'undefined') return;
      
      const getIconPath = () => {
        const hostname = window.location.hostname;
        const paths = [
          '/_expo/static/assets/images/icon.webp', // 開発環境（Expo Web）- WebP形式
          '/assets/images/icon.webp', // 本番環境 - WebP形式
          '/assets/images/icon.png', // PNG形式（フォールバック）
          '/images/icon.png', // publicディレクトリ（フォールバック）
        ];
        
        // 開発環境の判定
        if (hostname === 'localhost' || hostname === '127.0.0.1') {
          return paths[0]; // 開発環境では/_expo/static/を使用
        }
        
        return paths[1]; // 本番環境では/assets/を使用
      };
      
      const iconPath = getIconPath();
      
      // 既存のfaviconリンクを削除
      const existingLinks = document.querySelectorAll('link[rel="icon"], link[rel="shortcut icon"]');
      existingLinks.forEach(link => link.remove());
      
      // 新しいfaviconリンクを追加（WebP形式を優先、PNG形式をフォールバック）
      const link = document.createElement('link');
      link.rel = 'icon';
      link.type = 'image/webp';
      link.href = iconPath;
      link.onerror = function() {
        // WebPがサポートされていない場合はPNG形式にフォールバック
        this.href = iconPath.replace('.webp', '.png');
        this.type = 'image/png';
      };
      document.head.appendChild(link);
      
      const shortcutLink = document.createElement('link');
      shortcutLink.rel = 'shortcut icon';
      shortcutLink.type = 'image/webp';
      shortcutLink.href = iconPath;
      shortcutLink.onerror = function() {
        // WebPがサポートされていない場合はPNG形式にフォールバック
        this.href = iconPath.replace('.webp', '.png');
        this.type = 'image/png';
      };
      document.head.appendChild(shortcutLink);
    })();
  </script>
  <!-- フォールバック用の静的リンク（JavaScriptが無効な場合用、エラーを抑制） -->
  <!-- WebP形式を優先、PNG形式にフォールバック -->
  <link rel="icon" type="image/webp" href="/assets/images/icon.webp" onerror="this.href='/assets/images/icon.png'; this.type='image/png'; this.onerror=function(){this.href='/_expo/static/assets/images/icon.png';};" />
  <link rel="shortcut icon" type="image/webp" href="/assets/images/icon.webp" onerror="this.href='/assets/images/icon.png'; this.type='image/png'; this.onerror=function(){this.href='/_expo/static/assets/images/icon.png';};" />
  <title>Music Practice</title>
  <script>
    // 開発時のコンソールメッセージを早期に抑制（DOMレベル、Reactロード前）
    (function() {
      if (typeof window === 'undefined') return;
      
      // console.log, console.info, console.warnを早期にオーバーライド
      const originalConsoleLog = console.log;
      const originalConsoleInfo = console.info;
      const originalConsoleWarn = console.warn;
      
      console.log = function(...args) {
        const fullMessage = args.map(arg => String(arg)).join(' ');
        // React/Expo開発時の標準メッセージを抑制
        if (fullMessage.includes('Running application') ||
            fullMessage.includes('with appParams') ||
            fullMessage.includes('Development-level warnings') ||
            fullMessage.includes('Performance optimizations') ||
            fullMessage.includes('Development-level warnings: ON') ||
            fullMessage.includes('Performance optimizations: OFF')) {
          return;
        }
        originalConsoleLog.apply(console, args);
      };
      
      console.info = function(...args) {
        const fullMessage = args.map(arg => String(arg)).join(' ');
        // React DevToolsのダウンロード案内を抑制
        if (fullMessage.includes('Download the React DevTools') ||
            fullMessage.includes('react.dev/link/react-devtools') ||
            fullMessage.includes('React DevTools')) {
          return;
        }
        // Expo/React開発時の標準メッセージを抑制
        if (fullMessage.includes('Running application') ||
            fullMessage.includes('with appParams') ||
            fullMessage.includes('Development-level warnings') ||
            fullMessage.includes('Performance optimizations')) {
          return;
        }
        originalConsoleInfo.apply(console, args);
      };
      
      console.warn = function(...args) {
        const fullMessage = args.map(arg => String(arg)).join(' ');
        // React DevToolsのダウンロード案内を抑制
        if (fullMessage.includes('Download the React DevTools') ||
            fullMessage.includes('react.dev/link/react-devtools')) {
          return;
        }
        // aria-hidden警告を抑制
        if (fullMessage.includes('Blocked aria-hidden on an element') ||
            fullMessage.includes('aria-hidden') && fullMessage.includes('descendant retained focus') ||
            fullMessage.includes('The focus must not be hidden from assistive technology users')) {
          return;
        }
        originalConsoleWarn.apply(console, args);
      };
      
      // aria-hidden警告を根本的に抑制（DOMレベル）
      // inert属性を使用したモーダル管理と組み合わせて使用
      
      // フォーカス可能な要素のセレクタ
      const focusableSelector = 'input, textarea, select, button, a, [tabindex]:not([tabindex="-1"]), [contenteditable="true"]';
      
      // 要素がinert属性を持つか、その祖先がinert属性を持つかチェック
      const isInInertTree = function(element) {
        let current = element;
        while (current && current !== document.body) {
          if (current.hasAttribute && current.hasAttribute('inert')) {
            return true;
          }
          current = current.parentElement;
        }
        return false;
      };
      
      // モーダル状態を追跡するグローバル変数
      let isModalOpen = false;
      let openModals = new Set();
      
      // 要素がモーダル内にあるかチェック
      const isInModal = function(element) {
        if (!element) return false;
        return element.closest('[role="dialog"]') || 
               element.closest('[aria-modal="true"]') ||
               element.closest('[data-modal-content]');
      };
      
      // モーダルが開いているかどうかをチェック
      const checkModalState = function() {
        const modals = document.querySelectorAll('[role="dialog"], [aria-modal="true"], [data-modal-content]');
        const visibleModals = Array.from(modals).filter(modal => {
          const style = window.getComputedStyle(modal);
          return style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
        });
        openModals = new Set(visibleModals);
        isModalOpen = visibleModals.length > 0;
        return isModalOpen;
      };
      
      // モーダルの出現/消失を監視するMutationObserver
      const modalObserver = new MutationObserver(function(mutations) {
        let shouldCheck = false;
        mutations.forEach(function(mutation) {
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach(function(node) {
              if (node.nodeType === 1) { // Element node
                if (node.hasAttribute && (
                  node.hasAttribute('role') && node.getAttribute('role') === 'dialog' ||
                  node.hasAttribute('aria-modal') && node.getAttribute('aria-modal') === 'true' ||
                  node.hasAttribute('data-modal-content')
                )) {
                  shouldCheck = true;
                }
                // 子要素もチェック
                if (node.querySelector) {
                  const modalElements = node.querySelectorAll('[role="dialog"], [aria-modal="true"], [data-modal-content]');
                  if (modalElements.length > 0) {
                    shouldCheck = true;
                  }
                }
              }
            });
            mutation.removedNodes.forEach(function(node) {
              if (node.nodeType === 1) {
                if (openModals.has(node)) {
                  shouldCheck = true;
                }
              }
            });
          } else if (mutation.type === 'attributes') {
            const target = mutation.target;
            if (target && target.hasAttribute && (
              (mutation.attributeName === 'role' && target.getAttribute('role') === 'dialog') ||
              (mutation.attributeName === 'aria-modal' && target.getAttribute('aria-modal') === 'true') ||
              mutation.attributeName === 'style' ||
              mutation.attributeName === 'class'
            )) {
              shouldCheck = true;
            }
          }
        });
        
        if (shouldCheck) {
          checkModalState();
        }
      });
      
      // モーダル監視を開始
      if (document.body) {
        modalObserver.observe(document.body, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ['role', 'aria-modal', 'style', 'class', 'data-modal-content']
        });
        // 初期状態をチェック
        checkModalState();
      } else {
        document.addEventListener('DOMContentLoaded', function() {
          modalObserver.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['role', 'aria-modal', 'style', 'class', 'data-modal-content']
          });
          checkModalState();
        });
      }
      
      // aria-hidden属性の設定を根本的にブロック（inert属性を使用）
      const originalSetAttribute = Element.prototype.setAttribute;
      Element.prototype.setAttribute = function(name, value) {
        if (name === 'aria-hidden' && value === 'true') {
          // モーダルが開いている場合は、背景要素へのaria-hidden設定を完全にブロック
          if (isModalOpen) {
            // モーダル内の要素の場合は許可（モーダル自体にはaria-hiddenを設定しても良い）
            if (isInModal(this)) {
              return originalSetAttribute.call(this, name, value);
            }
            // 背景要素へのaria-hidden設定は完全にブロック
            // inert属性を設定して、再設定を防ぐ
            if (!this.hasAttribute('inert')) {
              this.setAttribute('inert', '');
            }
            return; // aria-hiddenの設定を完全にブロック
          }
          
          // display: noneの要素にはaria-hiddenを設定しない（display: noneで既に非表示）
          const computedStyle = window.getComputedStyle ? window.getComputedStyle(this) : null;
          if (computedStyle && computedStyle.display === 'none') {
            return; // aria-hiddenの設定をブロック（display: noneで既に非表示のため不要）
          }
          
          // インラインスタイルでdisplay: noneが設定されている場合もブロック
          const inlineDisplay = this.style ? this.style.display : '';
          if (inlineDisplay === 'none') {
            return; // aria-hiddenの設定をブロック
          }
          
          // モーダル内の要素の場合は許可（モーダル自体にはaria-hiddenを設定しても良い）
          if (isInModal(this)) {
            return originalSetAttribute.call(this, name, value);
          }
          
          // inert属性が設定されている場合は、aria-hiddenの設定をブロック（inertで十分）
          if (this.hasAttribute && this.hasAttribute('inert')) {
            return; // aria-hiddenの設定をブロック（inertで既に処理済み）
          }
          
          // React Native Webのクラスパターンをより広く検出（根本的な解決のため、早期にチェック）
          const hasRNWClasses = this.classList && (
            Array.from(this.classList).some(cls => 
              cls.startsWith('r-') || 
              cls.startsWith('css-view-') || 
              cls.includes('r-flex-') ||
              cls.includes('css-view-g5y9jx') ||
              cls.includes('r-flex-13awgt0') ||
              cls.includes('r-transitionProperty-') ||
              cls.includes('r-userSelect-') ||
              cls.includes('r-cursor-') ||
              cls.includes('r-touchAction-') ||
              cls.includes('r-alignItems-') ||
              cls.includes('r-backgroundColor-') ||
              cls.includes('r-borderRadius-') ||
              cls.includes('r-flexDirection-') ||
              cls.includes('r-gap-') ||
              cls.includes('r-minWidth-') ||
              cls.includes('r-paddingBlock-') ||
              cls.includes('r-paddingInline-') ||
              cls.includes('r-padding-')
            )
          );
          
          // 背景色チェック（rgb形式のバリエーションに対応）
          const bgColor = computedStyle ? computedStyle.backgroundColor : null;
          const inlineBgColor = this.style ? this.style.backgroundColor : null;
          const isGrayBackground = 
            (bgColor && (bgColor === 'rgb(242, 242, 242)' || bgColor.includes('242, 242, 242'))) ||
            (inlineBgColor && (inlineBgColor === 'rgb(242, 242, 242)' || inlineBgColor.includes('242, 242, 242')));
          
          // React Native Webのクラスパターンまたは背景色に一致する場合は即座にブロック（根本的な解決）
          if (hasRNWClasses || isGrayBackground) {
            // inert属性を設定（aria-hiddenの代わり）
            if (!this.hasAttribute('inert')) {
              this.setAttribute('inert', '');
            }
            return; // aria-hiddenの設定を完全にブロック
          }
          
          // React Native Webの背景要素かチェック
          const isBackgroundElement = 
            this === document.body || 
            this === document.getElementById('root') ||
            (this.parentElement && (this.parentElement === document.body || this.parentElement.id === 'root'));
          
          // フォーカスがこの要素内にある場合は即座にブロック（優先度を上げる）
          const activeElement = document.activeElement;
          if (activeElement && (this === activeElement || this.contains(activeElement))) {
            // モーダル内の要素の場合は許可
            if (!isInModal(activeElement)) {
              // モーダルが開いている場合は、フォーカスを外さずにaria-hiddenのみブロック
              if (isModalOpen) {
                // inert属性を設定
                if (!this.hasAttribute('inert')) {
                  this.setAttribute('inert', '');
                }
                return; // aria-hiddenの設定をブロック
              }
              // フォーカスを即座に外す（非同期で実行して確実に処理）
              if (activeElement.blur) {
                activeElement.blur();
              }
              // inert属性を設定
              if (!this.hasAttribute('inert')) {
                this.setAttribute('inert', '');
              }
              return; // aria-hiddenの設定をブロック
            }
          }
          
          // モーダルが開いている場合、背景要素内のフォーカス可能な要素を事前に検出
          if (isModalOpen) {
            try {
              const focusableElements = this.querySelectorAll ? this.querySelectorAll(focusableSelector) : [];
              if (focusableElements.length > 0) {
                // モーダル内の要素が含まれていない場合のみブロック
                const hasModalContent = Array.from(focusableElements).some(el => isInModal(el));
                if (!hasModalContent) {
                  // inert属性を設定
                  if (!this.hasAttribute('inert')) {
                    this.setAttribute('inert', '');
                  }
                  return; // aria-hiddenの設定を完全にブロック
                }
              }
            } catch (e) {
              // エラー時は安全のためブロック
              return;
            }
          }
          
          // フォーカス可能な要素が含まれている場合は設定を完全にブロック
          let hasFocusableDescendants = false;
          try {
            const focusableElements = this.querySelectorAll ? this.querySelectorAll(focusableSelector) : [];
            if (focusableElements.length > 0) {
              // モーダル内の要素の場合は許可
              const hasModalContent = Array.from(focusableElements).some(el => isInModal(el));
              if (!hasModalContent) {
                hasFocusableDescendants = true;
              }
            }
          } catch (e) {
            // エラー時は安全のためブロック
            return;
          }
          
          // 背景要素またはフォーカス可能な子要素がある場合は完全にブロック
          if (isBackgroundElement || hasFocusableDescendants) {
            // inert属性を設定（aria-hiddenの代わり）
            if (!this.hasAttribute('inert')) {
              // 非同期で設定して、フォーカス管理を確実にする
              setTimeout(() => {
                if (!this.hasAttribute('inert') && !isInModal(this)) {
                  this.setAttribute('inert', '');
                }
              }, 0);
            }
            return; // aria-hiddenの設定を完全にブロック
          }
          
          // その他の場合も、フォーカス可能な要素が含まれている可能性があるため、inert属性を使用
          try {
            // 子要素にフォーカス可能な要素があるかチェック（再帰的に）
            const hasFocusableDescendant = (element) => {
              if (!element) return false;
              try {
                const focusable = element.querySelectorAll ? element.querySelectorAll(focusableSelector) : [];
                if (focusable.length > 0) return true;
                // 子要素を再帰的にチェック
                for (let child of element.children || []) {
                  if (hasFocusableDescendant(child)) return true;
                }
              } catch (e) {
                // エラーは無視
              }
              return false;
            };
            
            if (hasFocusableDescendant(this)) {
              // inert属性を設定して、aria-hiddenの代わりにする
              if (!this.hasAttribute('inert')) {
                this.setAttribute('inert', '');
              }
              return; // aria-hiddenの設定をブロック
            }
          } catch (e) {
            // エラーが発生した場合は設定をブロック（安全のため）
            return;
          }
        }
        return originalSetAttribute.call(this, name, value);
      };
      
      // フォーカスイベントを監視して、フォーカスされた要素の祖先のaria-hiddenを削除
      const handleFocus = function(event) {
        const target = event.target;
        if (!target) return;
        
        // モーダル状態を更新
        checkModalState();
        
        // inert属性が設定されている場合は、aria-hiddenの削除は不要
        if (isInInertTree(target)) {
          return;
        }
        
        // モーダル内の要素の場合は、aria-hiddenの削除は不要
        if (isInModal(target)) {
          return;
        }
        
        // モーダルが開いている場合は、背景要素から即座にaria-hiddenを削除
        if (isModalOpen) {
          let current = target;
          while (current && current !== document.body && current !== document.documentElement) {
            if (current.hasAttribute && current.hasAttribute('aria-hidden') && current.getAttribute('aria-hidden') === 'true') {
              if (!isInInertTree(current) && !isInModal(current)) {
                current.removeAttribute('aria-hidden');
                if (!current.hasAttribute('inert')) {
                  current.setAttribute('inert', '');
                }
              }
            }
            current = current.parentElement;
          }
          return;
        }
        
        // フォーカスされた要素のすべての祖先をチェック（より積極的に削除）
        let current = target;
        while (current && current !== document.body && current !== document.documentElement) {
          if (current.hasAttribute && current.hasAttribute('aria-hidden') && current.getAttribute('aria-hidden') === 'true') {
            // inert属性が設定されている場合は削除しない
            if (!isInInertTree(current) && !isInModal(current)) {
              // 即座にaria-hiddenを削除（警告を防ぐ）
              current.removeAttribute('aria-hidden');
              // inert属性を設定して、再設定を防ぐ
              if (!current.hasAttribute('inert')) {
                current.setAttribute('inert', '');
              }
            }
          }
          current = current.parentElement;
        }
      };
      
      // より積極的にフォーカスイベントを監視（キャプチャフェーズとバブリングフェーズの両方）
      document.addEventListener('focusin', handleFocus, true); // キャプチャフェーズ
      document.addEventListener('focus', handleFocus, true); // キャプチャフェーズ
      
      // フォーカスが変更される前にaria-hiddenを削除（より早期に処理）
      const handleFocusBefore = function(event) {
        const target = event.target;
        if (!target) return;
        
        // モーダル状態を更新
        checkModalState();
        
        // inert属性が設定されている場合は、aria-hiddenの削除は不要
        if (isInInertTree(target)) {
          return;
        }
        
        // モーダル内の要素の場合は、aria-hiddenの削除は不要
        if (isInModal(target)) {
          return;
        }
        
        // モーダルが開いている場合は、背景要素から即座にaria-hiddenを削除
        if (isModalOpen) {
          let current = target;
          while (current && current !== document.body && current !== document.documentElement) {
            if (current.hasAttribute && current.hasAttribute('aria-hidden') && current.getAttribute('aria-hidden') === 'true') {
              if (!isInInertTree(current) && !isInModal(current)) {
                current.removeAttribute('aria-hidden');
                if (!current.hasAttribute('inert')) {
                  current.setAttribute('inert', '');
                }
              }
            }
            current = current.parentElement;
          }
          return;
        }
        
        // フォーカスされる要素のすべての祖先を事前にチェック
        let current = target;
        while (current && current !== document.body && current !== document.documentElement) {
          if (current.hasAttribute && current.hasAttribute('aria-hidden') && current.getAttribute('aria-hidden') === 'true') {
            if (!isInInertTree(current) && !isInModal(current)) {
              // 即座にaria-hiddenを削除（警告を防ぐ）
              current.removeAttribute('aria-hidden');
              // inert属性を設定して、再設定を防ぐ
              if (!current.hasAttribute('inert')) {
                current.setAttribute('inert', '');
              }
            }
          }
          current = current.parentElement;
        }
      };
      
      // フォーカスイベントの前に処理（より早期に）
      document.addEventListener('mousedown', handleFocusBefore, true);
      document.addEventListener('touchstart', handleFocusBefore, true);
      
      // aria-hidden警告を抑制（コンソール警告を無視）
      const originalWarn = console.warn;
      const originalError = console.error;
      console.warn = function(...args) {
        // aria-hiddenに関する警告は完全に無視
        if (args.length > 0) {
          const message = typeof args[0] === 'string' ? args[0] : String(args[0]);
          const fullMessage = args.map(arg => String(arg)).join(' ');
          if (message.includes('aria-hidden') || 
              message.includes('Blocked aria-hidden') ||
              fullMessage.includes('aria-hidden') ||
              fullMessage.includes('Blocked aria-hidden') ||
              fullMessage.includes('Ancestor with aria-hidden') ||
              fullMessage.includes('focus must not be hidden')) {
            return;
          }
        }
        originalWarn.apply(console, args);
      };
      
      // console.errorもaria-hidden関連の警告を抑制
      console.error = function(...args) {
        if (args.length > 0) {
          const message = typeof args[0] === 'string' ? args[0] : String(args[0]);
          const fullMessage = args.map(arg => String(arg)).join(' ');
          if (message.includes('aria-hidden') || 
              message.includes('Blocked aria-hidden') ||
              fullMessage.includes('aria-hidden') ||
              fullMessage.includes('Blocked aria-hidden') ||
              fullMessage.includes('Ancestor with aria-hidden') ||
              fullMessage.includes('focus must not be hidden')) {
            return;
          }
        }
        originalError.apply(console, args);
      };
      
      // DOMが読み込まれたらイベントリスナーを追加
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
          document.addEventListener('focusin', handleFocus, true);
        });
      } else {
        document.addEventListener('focusin', handleFocus, true);
      }
      
      // MutationObserverでaria-hidden属性の追加を監視（即座に削除）
      const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          if (mutation.type === 'attributes' && (mutation.attributeName === 'aria-hidden' || mutation.attributeName === 'style')) {
            const target = mutation.target;
            if (!target || !target.hasAttribute) return;
            
            // モーダルが開いている場合は、背景要素からaria-hiddenを即座に削除
            if (isModalOpen) {
              // モーダル内の要素の場合は許可
              if (isInModal(target)) {
                return;
              }
              // 背景要素からaria-hiddenを即座に削除
              if (target.hasAttribute('aria-hidden') && target.getAttribute('aria-hidden') === 'true') {
                target.removeAttribute('aria-hidden');
                // inert属性を設定して、再設定を防ぐ
                if (!target.hasAttribute('inert')) {
                  target.setAttribute('inert', '');
                }
                return;
              }
            }
            
            // inert属性が設定されている場合は、aria-hiddenの削除は不要
            if (isInInertTree(target)) {
              return;
            }
            
            // モーダル内の要素の場合は許可
            if (isInModal(target)) {
              return;
            }
            
            // display: noneの要素からaria-hiddenを削除
            const computedStyle = window.getComputedStyle ? window.getComputedStyle(target) : null;
            const isDisplayNone = (computedStyle && computedStyle.display === 'none') || 
                                  (target.style && target.style.display === 'none');
            
            if (isDisplayNone && target.hasAttribute('aria-hidden') && target.getAttribute('aria-hidden') === 'true') {
              // display: noneの要素にはaria-hiddenは不要
              target.removeAttribute('aria-hidden');
              return;
            }
            
            // aria-hiddenが設定されている場合、即座に削除
            if (target.hasAttribute('aria-hidden') && target.getAttribute('aria-hidden') === 'true') {
              // React Native Webのクラスパターンをチェック
              const hasRNWClasses = target.classList && (
                Array.from(target.classList).some(cls => 
                  cls.startsWith('r-') || 
                  cls.startsWith('css-view-') ||
                  cls.includes('css-view-g5y9jx') ||
                  cls.includes('r-flex-13awgt0')
                )
              );
              
              const computedStyle = window.getComputedStyle ? window.getComputedStyle(target) : null;
              const bgColor = computedStyle ? computedStyle.backgroundColor : null;
              const isGrayBackground = bgColor && bgColor.includes('242, 242, 242');
              
              // 背景要素のチェック
              const isBackgroundElement = target === document.body || 
                                          target === document.getElementById('root') ||
                                          (target.parentElement && (target.parentElement === document.body || target.parentElement.id === 'root')) ||
                                          hasRNWClasses ||
                                          isGrayBackground;
              
              // フォーカス可能な要素をチェック
              let shouldRemove = false;
              try {
                // 現在フォーカスされている要素を含むかチェック
                const activeElement = document.activeElement;
                if (activeElement && target.contains(activeElement)) {
                  if (!isInModal(activeElement)) {
                    shouldRemove = true;
                    if (activeElement.blur) {
                      activeElement.blur();
                    }
                  }
                }
                
                const focusableElements = target.querySelectorAll ? target.querySelectorAll(focusableSelector) : [];
                if (focusableElements.length > 0) {
                  // モーダル内の要素の場合は許可
                  const hasModalContent = Array.from(focusableElements).some(el => isInModal(el));
                  if (!hasModalContent) {
                    shouldRemove = true;
                  }
                }
                
                // 背景要素の場合は削除
                if (isBackgroundElement) {
                  shouldRemove = true;
                }
                
                if (shouldRemove) {
                  target.removeAttribute('aria-hidden');
                  if (!target.hasAttribute('inert')) {
                    target.setAttribute('inert', '');
                  }
                }
              } catch (e) {
                // エラーが発生した場合は無視
              }
            }
          }
          
          // ノードが追加された場合もチェック
          if (mutation.type === 'childList') {
            mutation.addedNodes.forEach(function(node) {
              if (node.nodeType === 1) { // Element node
                const element = node;
                if (element.hasAttribute && element.hasAttribute('aria-hidden') && element.getAttribute('aria-hidden') === 'true') {
                  // inert属性が設定されている場合は、aria-hiddenの削除は不要
                  if (isInInertTree(element)) {
                    return;
                  }
                  
                  // モーダル内の要素の場合は許可
                  if (isInModal(element)) {
                    return;
                  }
                  
                  try {
                    const focusableElements = element.querySelectorAll ? element.querySelectorAll(focusableSelector) : [];
                    if (focusableElements.length > 0) {
                      // モーダル内の要素の場合は許可
                      const hasModalContent = Array.from(focusableElements).some(el => isInModal(el));
                      if (!hasModalContent) {
                        // 即座にaria-hiddenを削除し、inert属性を設定
                        element.removeAttribute('aria-hidden');
                        if (!element.hasAttribute('inert')) {
                          element.setAttribute('inert', '');
                        }
                        return;
                      }
                    }
                    
                    // フォーカス可能な要素がなくても、背景要素の場合は削除
                    const isBackgroundElement = element === document.body || 
                                              element === document.getElementById('root') ||
                                              (element.parentElement && (element.parentElement === document.body || element.parentElement.id === 'root')) ||
                                              (element.classList && (element.classList.contains('r-flex-13awgt0') || element.classList.contains('css-view-g5y9jx')));
                    
                    if (isBackgroundElement) {
                      element.removeAttribute('aria-hidden');
                      if (!element.hasAttribute('inert')) {
                        element.setAttribute('inert', '');
                      }
                    }
                  } catch (e) {
                    // エラーが発生した場合は無視
                  }
                }
              }
            });
          }
        });
      });
      
      // DOMが読み込まれたら監視を開始
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
          observer.observe(document.body, {
            attributes: true,
            attributeFilter: ['aria-hidden', 'style'],
            subtree: true,
            childList: true
          });
        });
      } else {
        observer.observe(document.body, {
          attributes: true,
          attributeFilter: ['aria-hidden', 'style'],
          subtree: true,
          childList: true
        });
      }
      
      // 定期的にaria-hiddenをチェック（フォールバック）- より頻繁にチェック
      // より頻繁にチェックしてaria-hiddenを削除（警告を防ぐため）
      setInterval(function() {
        // モーダル状態を更新
        checkModalState();
        
        const elementsWithAriaHidden = document.querySelectorAll('[aria-hidden="true"]');
        elementsWithAriaHidden.forEach(function(element) {
          // モーダルが開いている場合は、背景要素から即座に削除
          if (isModalOpen && !isInModal(element)) {
            element.removeAttribute('aria-hidden');
            if (!element.hasAttribute('inert')) {
              element.setAttribute('inert', '');
            }
            return;
          }
          
          // inert属性が設定されている場合は、aria-hiddenの削除は不要
          if (isInInertTree(element)) {
            return;
          }
          
          // モーダル内の要素の場合は許可
          if (isInModal(element)) {
            return;
          }
          
          // display: noneの要素からaria-hiddenを削除
          const computedStyle = window.getComputedStyle ? window.getComputedStyle(element) : null;
          const isDisplayNone = (computedStyle && computedStyle.display === 'none') || 
                                (element.style && element.style.display === 'none');
          
          if (isDisplayNone) {
            // display: noneの要素にはaria-hiddenは不要
            element.removeAttribute('aria-hidden');
            return;
          }
          
          // 現在フォーカスされている要素がこの要素の子孫である場合は即座に削除
          const activeElement = document.activeElement;
          if (activeElement && element.contains(activeElement)) {
            if (!isInModal(activeElement)) {
              element.removeAttribute('aria-hidden');
              if (!element.hasAttribute('inert')) {
                element.setAttribute('inert', '');
              }
              return;
            }
          }
          
          try {
            const focusableElements = element.querySelectorAll ? element.querySelectorAll(focusableSelector) : [];
            if (focusableElements.length > 0) {
              // モーダル内の要素の場合は許可
              const hasModalContent = Array.from(focusableElements).some(el => isInModal(el));
              if (!hasModalContent) {
                // 即座にaria-hiddenを削除し、inert属性を設定
                element.removeAttribute('aria-hidden');
                if (!element.hasAttribute('inert')) {
                  element.setAttribute('inert', '');
                }
                return;
              }
            }
            
            // フォーカス可能な要素がなくても、背景要素の場合は削除
            // React Native Webのクラス名パターンに一致する要素も削除
            const hasRNWClasses = element.classList && (
              Array.from(element.classList).some(cls => 
                cls.startsWith('r-') || 
                cls.startsWith('css-view-') ||
                cls.includes('css-view-g5y9jx') ||
                cls.includes('r-flex-13awgt0')
              )
            );
            
            const computedStyle = window.getComputedStyle ? window.getComputedStyle(element) : null;
            const bgColor = computedStyle ? computedStyle.backgroundColor : null;
            const isGrayBackground = bgColor && bgColor.includes('242, 242, 242');
            
            const isBackgroundElement = element === document.body || 
                                      element === document.getElementById('root') ||
                                      (element.parentElement && (element.parentElement === document.body || element.parentElement.id === 'root')) ||
                                      hasRNWClasses ||
                                      isGrayBackground;
            
            if (isBackgroundElement) {
              element.removeAttribute('aria-hidden');
              if (!element.hasAttribute('inert')) {
                element.setAttribute('inert', '');
              }
            }
            
            // フォーカス可能な子要素を持つ要素の場合も削除（より積極的に）
            try {
              const hasFocusableChild = element.querySelector && element.querySelector(
                'input, textarea, select, button, a, [tabindex]:not([tabindex="-1"]), [contenteditable="true"]'
              );
              if (hasFocusableChild && !isInModal(element) && !isInInertTree(element)) {
                element.removeAttribute('aria-hidden');
                if (!element.hasAttribute('inert')) {
                  element.setAttribute('inert', '');
                }
              }
            } catch (e) {
              // エラーは無視
            }
          } catch (e) {
            // エラーが発生した場合は無視
          }
        });
      }, 50); // 100ms → 50msに短縮（より頻繁にチェックして警告を防ぐ）
    })();
  </script>
  <style>
    html, body, #root {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    #root {
      display: flex;
      flex-direction: column;
    }
    /* Expo Routerタブバーのスクロール矢印を非表示 */
    [data-testid*="scroll-arrow"],
    [class*="scroll-arrow"],
    [class*="ScrollArrow"],
    button[aria-label*="scroll"],
    button[aria-label*="arrow"],
    button[aria-label*="arrow-down"],
    svg[class*="arrow"],
    [class*="chevron-down"] {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
      visibility: hidden !important;
      opacity: 0 !important;
    }
    
    /* タブバーの右側の余白を完全に削除 */
    nav[role="tablist"],
    [class*="tab-bar"],
    [class*="TabBar"] {
      padding-right: 0 !important;
      margin-right: 0 !important;
      width: 100% !important;
      max-width: 100% !important;
      overflow: hidden !important;
    }
    
    /* タブバーの最後の要素の右側余白を削除 */
    nav[role="tablist"] > *:last-child,
    [class*="tab-bar"] > *:last-child,
    [class*="TabBar"] > *:last-child {
      padding-right: 0 !important;
      margin-right: 0 !important;
    }
    
    /* タブバーのルートコンテナとすべての親要素の余白を削除 */
    nav[role="tablist"],
    nav[class*="tab"],
    nav[class*="Tab"],
    div[class*="tab-bar"],
    div[class*="TabBar"],
    [class*="tab-bar"],
    [class*="TabBar"],
    [role="tablist"],
    [data-testid*="tab-bar"],
    [data-testid*="TabBar"] {
      padding: 0 !important;
      padding-left: 0 !important;
      padding-right: 0 !important;
      padding-top: 0 !important;
      padding-bottom: 0 !important;
      margin: 0 !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
      margin-top: 0 !important;
      margin-bottom: 0 !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 100% !important;
      box-sizing: border-box !important;
      overflow: hidden !important;
    }
    
    /* タブバーのスクロールコンテナの余白を削除 */
    [class*="tab-bar"] [class*="scroll"],
    [class*="TabBar"] [class*="scroll"],
    [class*="tab-bar"] [class*="ScrollView"],
    [class*="TabBar"] [class*="ScrollView"],
    [role="tablist"] [class*="scroll"],
    [role="tablist"] [class*="ScrollView"],
    nav[role="tablist"] > div,
    nav[class*="tab"] > div,
    [class*="tab-bar"] > div,
    [class*="TabBar"] > div {
      padding: 0 !important;
      padding-left: 0 !important;
      padding-right: 0 !important;
      margin: 0 !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
      width: 100% !important;
      max-width: 100% !important;
      min-width: 100% !important;
      box-sizing: border-box !important;
      overflow-x: hidden !important;
      overflow-y: hidden !important;
    }
    
    /* タブバーのコンテンツコンテナの余白を削除 */
    [class*="tab-bar"] > *,
    [class*="TabBar"] > *,
    [role="tablist"] > *,
    [class*="tab-bar"] [class*="content"],
    [class*="TabBar"] [class*="content"],
    nav[role="tablist"] > *,
    nav[class*="tab"] > * {
      padding: 0 !important;
      padding-left: 0 !important;
      padding-right: 0 !important;
      margin: 0 !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
      box-sizing: border-box !important;
    }
    
    /* タブバーの最後の要素の余白を削除 */
    [class*="tab-bar"] > *:last-child,
    [class*="TabBar"] > *:last-child,
    [role="tablist"] > *:last-child,
    [class*="tab-bar"] [class*="content"] > *:last-child,
    [class*="TabBar"] [class*="content"] > *:last-child,
    nav[role="tablist"] > *:last-child {
      padding-right: 0 !important;
      margin-right: 0 !important;
    }
    
    /* タブアイテムの余白を削除（表示されているタブのみ） */
    [class*="tab-bar"] button:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty),
    [class*="TabBar"] button:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty),
    [role="tablist"] button:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty),
    [role="tab"]:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty),
    [class*="tab-item"]:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty),
    [class*="TabItem"]:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty),
    nav[role="tablist"] button:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty),
    nav[class*="tab"] button:not([style*="display: none"]):not([style*="width: 0"]):not([style*="flex: 0"]):not(:empty) {
      padding: 0 !important;
      padding-left: 0 !important;
      padding-right: 0 !important;
      margin: 0 !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
      flex: 1 !important;
      min-width: 0 !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
      width: auto !important;
    }
    
    /* 非表示タブ（空のボタンや幅0のボタン）を完全に削除 */
    [class*="tab-bar"] button:empty,
    [class*="TabBar"] button:empty,
    [role="tablist"] button:empty,
    [role="tab"]:empty,
    [class*="tab-bar"] button[style*="display: none"],
    [class*="TabBar"] button[style*="display: none"],
    [role="tablist"] button[style*="display: none"],
    [class*="tab-bar"] button[aria-hidden="true"],
    [class*="TabBar"] button[aria-hidden="true"],
    [role="tablist"] button[aria-hidden="true"],
    /* 幅0またはflex: 0の要素を非表示 */
    [class*="tab-bar"] button[style*="width: 0"],
    [class*="TabBar"] button[style*="width: 0"],
    [role="tablist"] button[style*="width: 0"],
    [class*="tab-bar"] button[style*="flex: 0"],
    [class*="TabBar"] button[style*="flex: 0"],
    [role="tablist"] button[style*="flex: 0"] {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
      padding: 0 !important;
      margin: 0 !important;
      visibility: hidden !important;
      opacity: 0 !important;
      flex: 0 !important;
      min-width: 0 !important;
      max-width: 0 !important;
      position: absolute !important;
      left: -9999px !important;
    }
    
    /* 非表示タブの親要素もスペースを取らないようにする */
    [class*="tab-bar"] > *:empty,
    [class*="TabBar"] > *:empty,
    [role="tablist"] > *:empty {
      display: none !important;
      width: 0 !important;
      padding: 0 !important;
      margin: 0 !important;
      flex: 0 !important;
    }
    
    /* タブバーのコンテンツコンテナで、表示されているタブのみをカウント */
    [role="tablist"] > *:not([style*="display: none"]):not(:empty):not([style*="width: 0"]):not([style*="flex: 0"]) {
      flex: 1 !important;
    }
    
    /* 非表示タブの親要素もスペースを取らないようにする */
    [role="tablist"] > *[style*="display: none"],
    [role="tablist"] > *[style*="width: 0"],
    [role="tablist"] > *[style*="flex: 0"] {
      display: none !important;
      width: 0 !important;
      flex: 0 !important;
      padding: 0 !important;
      margin: 0 !important;
    }
    
    /* タブバーの右側の余白を完全に削除（すべての要素に対して） */
    [role="tablist"] * {
      box-sizing: border-box !important;
    }
    
    /* タブバーの最後の表示されているタブの右側余白を削除 */
    [role="tablist"] > *:last-child:not([style*="display: none"]):not(:empty),
    [role="tablist"] > *:last-child button,
    [role="tablist"] > *:last-child [role="tab"],
    nav[role="tablist"] > *:last-child:not([style*="display: none"]):not(:empty),
    nav[role="tablist"] > *:last-child button,
    nav[role="tablist"] > *:last-child [role="tab"],
    [class*="tab-bar"] > *:last-child,
    [class*="TabBar"] > *:last-child {
      padding-right: 0 !important;
      margin-right: 0 !important;
      padding-end: 0 !important;
      margin-end: 0 !important;
      border-right: none !important;
    }
    
    /* タブバーのコンテナ全体の右側余白を削除 */
    [role="tablist"],
    nav[role="tablist"],
    [class*="tab-bar"],
    [class*="TabBar"],
    [class*="tab-bar-content"],
    [class*="TabBarContent"] {
      padding-right: 0 !important;
      margin-right: 0 !important;
      padding-end: 0 !important;
      margin-end: 0 !important;
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
    }
    
    /* タブバーの内部コンテナの右側余白を削除 */
    [role="tablist"] > div,
    nav[role="tablist"] > div,
    [class*="tab-bar"] > div,
    [class*="TabBar"] > div {
      padding-right: 0 !important;
      margin-right: 0 !important;
      padding-end: 0 !important;
      margin-end: 0 !important;
      width: 100% !important;
      max-width: 100% !important;
    }
    
    /* タブバーのすべての子要素の余白を削除（再帰的） */
    [class*="tab-bar"] *,
    [class*="TabBar"] *,
    [role="tablist"] *,
    nav[role="tablist"] * {
      box-sizing: border-box !important;
    }
    
    /* タブバーの親コンテナの余白も削除 */
    body > div,
    #root > div,
    [class*="expo-router"] {
      padding-right: 0 !important;
      margin-right: 0 !important;
      width: 100% !important;
      max-width: 100% !important;
      box-sizing: border-box !important;
    }
    
    /* タブバーの右側余白を完全に削除 - より強力なルール */
    nav[role="tablist"] {
      justify-content: flex-start !important;
    }
    
    /* タブバーの最後のタブの右側余白を完全に削除 */
    nav[role="tablist"] > button:last-child,
    nav[role="tablist"] > a:last-child,
    nav[role="tablist"] > div:last-child button,
    [class*="tab-bar"] button:last-child,
    [class*="TabBar"] button:last-child {
      padding-right: 0 !important;
      margin-right: 0 !important;
      padding-end: 0 !important;
      margin-end: 0 !important;
      border-right: none !important;
    }
    
    /* タブバーのコンテナ全体を100%幅に */
    nav[role="tablist"],
    [class*="tab-bar"],
    [class*="TabBar"] {
      width: 100vw !important;
      max-width: 100vw !important;
      margin-right: 0 !important;
      padding-right: 0 !important;
    }
    
    /* すべてのタブボタンを均等に配置 */
    nav[role="tablist"] > button,
    nav[role="tablist"] > a,
    [class*="tab-bar"] button,
    [class*="TabBar"] button {
      flex: 1 1 0% !important;
      min-width: 0 !important;
      max-width: 100% !important;
    }
    
    /* タブバーの右側余白を完全に削除 - 最強のルール */
    body,
    html,
    #root,
    #root > *,
    [class*="expo-router"],
    [data-expo-router-root],
    nav[role="tablist"],
    nav[role="tablist"] *,
    [class*="tab-bar"],
    [class*="tab-bar"] *,
    [class*="TabBar"],
    [class*="TabBar"] * {
      box-sizing: border-box !important;
    }
    
    /* タブバーコンテナの右側余白を完全に削除 */
    nav[role="tablist"]:after,
    nav[role="tablist"]::after,
    [class*="tab-bar"]:after,
    [class*="tab-bar"]::after,
    [class*="TabBar"]:after,
    [class*="TabBar"]::after {
      display: none !important;
      content: none !important;
      width: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
    }
    
    /* タブバー全体の幅を100vwに固定し、右側余白を削除 */
    nav[role="tablist"],
    [class*="tab-bar"],
    [class*="TabBar"] {
      position: relative !important;
      left: 0 !important;
      right: 0 !important;
      width: 100vw !important;
      max-width: 100vw !important;
      margin-right: 0 !important;
      padding-right: 0 !important;
      padding-end: 0 !important;
      margin-end: 0 !important;
      overflow: hidden !important;
    }
    
    /* タブバーの最後の要素とそのすべての子要素の右側余白を削除 */
    nav[role="tablist"] > *:last-child,
    nav[role="tablist"] > *:last-child *,
    [class*="tab-bar"] > *:last-child,
    [class*="tab-bar"] > *:last-child *,
    [class*="TabBar"] > *:last-child,
    [class*="TabBar"] > *:last-child * {
      padding-right: 0 !important;
      margin-right: 0 !important;
      padding-end: 0 !important;
      margin-end: 0 !important;
      border-right: none !important;
    }
    
    /* タブバーのコンテンツを左寄せし、右側に余白を作らない */
    nav[role="tablist"],
    [class*="tab-bar-content"],
    [class*="TabBarContent"] {
      justify-content: flex-start !important;
      align-items: stretch !important;
      width: 100% !important;
      max-width: 100% !important;
      flex-wrap: nowrap !important;
    }
    
    /* すべてのタブアイテムを均等に配置し、右側余白を削除 */
    [role="tablist"] > *,
    [class*="tab-bar"] > *,
    [class*="TabBar"] > * {
      flex: 1 1 0% !important;
      min-width: 0 !important;
      padding-right: 0 !important;
      margin-right: 0 !important;
      padding-end: 0 !important;
      margin-end: 0 !important;
      box-sizing: border-box !important;
    }
  </style>
  <!-- Expo Router Web Support -->
  <script>
    // Expo RouterのWebルーティングを有効化
    // すべてのルートをindex.htmlにリダイレクト
    if (typeof window !== 'undefined') {
      // クライアントサイドルーティングを有効化
      window.__EXPO_ROUTER_ENABLED__ = true;
    }
  </script>
</head>
<body>
  <div id="root"></div>
</body>
</html>
